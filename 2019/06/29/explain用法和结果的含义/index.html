<!doctype html>
<html lang="en">

<!-- Head -->
<!doctype html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/image/favicon.jpg">
    

    <title>
        
        explain用法和结果的含义 |
        
        keep moving on
    </title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Plugin CSS -->


    <!-- Custom CSS -->
    <!-- ↓这是stylus文件 -->
    <link rel="stylesheet" href="/lhj/css/style.css">
    <link rel="stylesheet" href="/lhj/css/home.css">
    <link rel="stylesheet" href="/lhj/css/highlight.css">
    <link rel="stylesheet" href="/lhj/css/toc.css">


</head>
<body></body>
</html>

<body>

<!-- Header -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header {
     background-image: url('/lhj/image/header.jpg'); 
	/*
	 background-image: url('');
        /*post*/
    
	*/
    }
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- 文章 -->
                
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/lhj/tags/数据库" title="数据库">数据库</a>
                        
                    </div>
                    <h1>explain用法和结果的含义</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                            Posted by linhuanjie on
                        2019-06-29
                        </span>
                </div>
                <!-- 非文章 -->
                

            </div>
        </div>
    </div>
</header>

<!-- Nav -->
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/lhj/">keep moving on</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<!-- Content -->
<!-- Content -->
<div class="container">
    <div class="row">
        <!-- Post container -->

        <div class="
                col-lg-8 col-lg-offset-1
                col-md-8 col-md-offset-1
                col-sm-12
                col-xs-12
                post-container
            ">

            <blockquote>
<p>作者： <a href="https://home.cnblogs.com/u/yycc/" target="_blank" rel="noopener">有肉的三明治</a></p>
<p>原文：<a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="noopener">mysql explain用法和结果的含义</a></p>
</blockquote>
<p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助<strong>选择更好的索引</strong>和<strong>写出更优化的查询</strong>语句。</p>
<p>使用方法，在select语句前加上explain就可以了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ </span></span><br><span class="line">3. | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100453 |   100.00 |       | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------+-------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="每一列的含义"><a href="#每一列的含义" class="headerlink" title="每一列的含义"></a>每一列的含义</h3><table>
<thead>
<tr>
<th><strong>id</strong></th>
<th><br>SELECT识别符。这是SELECT的查询序列号<br><br></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>select_type</strong></td>
<td><br>SELECT类型,可以为以下任何一种:<br><strong>SIMPLE</strong>:简单SELECT(不使用UNION或子查询)<br><strong>PRIMARY</strong>:最外面的SELECT<br><strong>UNION</strong>:UNION中的第二个或后面的SELECT语句<br><strong>DEPENDENT UNION</strong>:UNION中的第二个或后面的SELECT语句,取决于外面的查询<br><strong>UNION RESULT</strong>:UNION 的结果<br><strong>SUBQUERY</strong>:子查询中的第一个SELECT<br><strong>DEPENDENT SUBQUERY</strong>:子查询中的第一个SELECT,取决于外面的查询<br><strong>DERIVED</strong>:导出表的SELECT(FROM子句的子查询)<br><br></td>
</tr>
<tr>
<td><strong>table</strong></td>
<td><br>输出的行所引用的表<br><br></td>
</tr>
<tr>
<td><strong>type</strong></td>
<td><br>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:<br><strong>system</strong>:表仅有一行(=系统表)。这是const联接类型的一个特例。<br><strong>const</strong>:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!<br><strong>eq_ref</strong>:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。<br><strong>ref</strong>:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。<br><strong>ref_or_null</strong>:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。<br><strong>index_merge</strong>:该联接类型表示使用了索引合并优化方法。<br><strong>unique_subquery</strong>:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。<br><strong>index_subquery</strong>:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)<br><strong>range</strong>:只检索给定范围的行,使用一个索引来选择行。<br><strong>index</strong>:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。<br><strong>ALL</strong>:对于每个来自于先前的表的行组合,进行完整的表扫描。<br><br></td>
</tr>
<tr>
<td><strong>possible_keys</strong></td>
<td><br>指出MySQL能使用哪个索引在该表中找到行<br><br></td>
</tr>
<tr>
<td><strong>key</strong></td>
<td><br>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。<br><br></td>
</tr>
<tr>
<td><strong>key_len</strong></td>
<td><br>显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。<br><br></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><br>显示使用哪个列或常数与key一起从表中选择行。<br><br></td>
</tr>
<tr>
<td><strong>rows</strong></td>
<td><br>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。<br><br></td>
</tr>
<tr>
<td><strong>filtered</strong></td>
<td><br>显示了通过条件过滤出的行数的百分比估计值。<br><br></td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td><br>该列包含MySQL解决查询的详细信息<br><strong>Distinct</strong>:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。<br><strong>Not exists</strong>:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。<br><strong>range checked for each record (index map: #)</strong>:MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。<br><strong>Using filesort</strong>:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。<br><strong>Using index</strong>:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。<br><strong>Using temporary</strong>:为了解决查询,MySQL需要创建一个临时表来容纳结果。<br><strong>Using where</strong>:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。<br><strong>Using sort_union(…), Using union(…), Using intersect(…)</strong>:这些函数说明如何为index_merge联接类型合并索引扫描。<br><strong>Using index for group-by</strong>:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。<br><br></td>
</tr>
</tbody>
</table>
<h3 id="一-select-type的说明"><a href="#一-select-type的说明" class="headerlink" title="一.select_type的说明"></a><strong>一.select_type的说明</strong></h3><p><strong>1.UNION:</strong></p>
<p>当通过union来连接多个查询结果时，第二个之后的select其select_type为UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id=100 union select * from t_order where order_id=200; </span><br><span class="line">2. +<span class="comment">----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ </span></span><br><span class="line">3. | id | select_type  | table      | type  | possible_keys | key     | key_len | ref   | rows | Extra | </span><br><span class="line">4. +<span class="comment">----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ </span></span><br><span class="line">5. |  1 | PRIMARY      | t_order    | const | PRIMARY       | PRIMARY | 4       | const |    1 |       | </span><br><span class="line">6. |  2 | UNION        | t_order    | const | PRIMARY       | PRIMARY | 4       | const |    1 |       | </span><br><span class="line">7. | NULL | UNION RESULT | &lt;union1,2&gt; | ALL   | NULL          | NULL    | NULL    | NULL  | NULL |       | </span><br><span class="line">8. +<span class="comment">----+--------------+------------+-------+---------------+---------+---------+-------+------+-------+ </span></span><br><span class="line">9. 3 rows in <span class="keyword">set</span> (<span class="number">0.34</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>2.DEPENDENT UNION与DEPENDENT SUBQUERY:</strong></p>
<p>当union作为子查询时，其中第二个union的select_type就是DEPENDENT UNION。<br>第一个子查询的select_type则是DEPENDENT SUBQUERY。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where order_id=100 union select order_id from t_order where order_id=200); </span><br><span class="line">2. +<span class="comment">----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ </span></span><br><span class="line">3. | id | select_type        | table      | type  | possible_keys | key     | key_len | ref   | rows   | Extra       | </span><br><span class="line">4. +<span class="comment">----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ </span></span><br><span class="line">5. |  1 | PRIMARY            | t_order    | ALL   | NULL          | NULL    | NULL    | NULL  | 100453 | Using where | </span><br><span class="line">6. |  2 | DEPENDENT SUBQUERY | t_order    | const | PRIMARY       | PRIMARY | 4       | const |      1 | Using index | </span><br><span class="line">7. |  3 | DEPENDENT UNION    | t_order    | const | PRIMARY       | PRIMARY | 4       | const |      1 | Using index | </span><br><span class="line">8. | NULL | UNION RESULT       | &lt;union2,3&gt; | ALL   | NULL          | NULL    | NULL    | NULL  |   NULL |             | </span><br><span class="line">9. +<span class="comment">----+--------------------+------------+-------+---------------+---------+---------+-------+--------+-------------+ </span></span><br><span class="line">10. 4 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>3.SUBQUERY:</strong></p>
<p>子查询中的第一个select其select_type为SUBQUERY。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id=(select order_id from t_order where order_id=100); </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ </span></span><br><span class="line">3. | id | select_type | table   | type  | possible_keys | key     | key_len | ref   | rows | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ </span></span><br><span class="line">5. |  1 | PRIMARY     | t_order | const | PRIMARY       | PRIMARY | 4       | const |    1 |             | </span><br><span class="line">6. |  2 | SUBQUERY    | t_order | const | PRIMARY       | PRIMARY | 4       |       |    1 | Using index | </span><br><span class="line">7. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+-------+------+-------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>4.DERIVED:</strong></p>
<p>当子查询是from子句时，其select_type为DERIVED。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from (select order_id from t_order where order_id=100) a; </span><br><span class="line">2. +<span class="comment">----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">3. | id | select_type | table      | type   | possible_keys | key     | key_len | ref  | rows | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">5. |  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL |    1 |             | </span><br><span class="line">6. |  2 | DERIVED     | t_order    | const  | PRIMARY       | PRIMARY | 4       |      |    1 | Using index | </span><br><span class="line">7. +<span class="comment">----+-------------+------------+--------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="二-type的说明"><a href="#二-type的说明" class="headerlink" title="二.type的说明"></a><strong>二.type的说明</strong></h3><p><strong>1.system，const</strong></p>
<p>见上面4.DERIVED的例子。其中第一行的type就是为system，第二行是const，这两种联接类型是最快的。</p>
<p><strong>2.eq_ref</strong></p>
<p>在t_order表中的order_id是主键，t_order_ext表中的order_id也是主键，该表可以认为是订单表的补充信息表，他们的关系是1对1，在下面的例子中可以看到b表的连接类型是eq_ref，这是极快的联接类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id; </span><br><span class="line">2. +<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ </span></span><br><span class="line">3. | id | select_type | table | type   | possible_keys | key     | key_len | ref             | rows | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | b     | ALL    | order_id      | NULL    | NULL    | NULL            |    1 |             | </span><br><span class="line">6. |  1 | SIMPLE      | a     | eq_ref | PRIMARY       | PRIMARY | 4       | test.b.order_id |    1 | Using where | </span><br><span class="line">7. +<span class="comment">----+-------------+-------+--------+---------------+---------+---------+-----------------+------+-------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>3.ref</strong></p>
<p>下面的例子在上面的例子上略作了修改，加上了条件。此时b表的联接类型变成了ref。因为所有与a表中order_id=100的匹配记录都将会从b表获取。这是比较常见的联接类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order a,t_order_ext b where a.order_id=b.order_id and a.order_id=100; </span><br><span class="line">2. +<span class="comment">----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ </span></span><br><span class="line">3. | id | select_type | table | type  | possible_keys | key      | key_len | ref   | rows | Extra | </span><br><span class="line">4. +<span class="comment">----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | a     | const | PRIMARY       | PRIMARY  | 4       | const |    1 |       | </span><br><span class="line">6. |  1 | SIMPLE      | b     | ref   | order_id      | order_id | 4       | const |    1 |       | </span><br><span class="line">7. +<span class="comment">----+-------------+-------+-------+---------------+----------+---------+-------+------+-------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>4.ref_or_null</strong></p>
<p>user_id字段是一个可以为空的字段，并对该字段创建了一个索引。在下面的查询中可以看到联接类型为ref_or_null，这是mysql为含有null的字段专门做的处理。在我们的表设计中应当尽量避免索引字段为NULL，因为这会额外的耗费mysql的处理时间来做优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where user_id=100 or user_id is null; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ </span></span><br><span class="line">3. | id | select_type | table   | type        | possible_keys | key     | key_len | ref   | rows  | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | ref_or_null | user_id       | user_id | 5       | const | 50325 | Using where | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------------+---------------+---------+---------+-------+-------+-------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>5.index_merge</strong></p>
<p>经常出现在使用一张表中的多个索引时。mysql会将多个索引合并在一起，如下例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id=100 or user_id=10; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ </span></span><br><span class="line">3. | id | select_type | table   | type        | possible_keys   | key             | key_len | ref  | rows | Extra                                     | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | index_merge | PRIMARY,user_id | PRIMARY,user_id | 4,5     | NULL |    2 | Using union(PRIMARY,user_id); Using where | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+-------------------------------------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>6.unique_subquery</strong></p>
<p>该联接类型用于替换value IN (SELECT primary_key FROM single_table WHERE some_expr)这样的子查询的ref。注意ref列，其中第二行显示的是func，表明unique_subquery是一个函数，而不是一个普通的ref。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id in (select order_id from t_order where user_id=10); </span><br><span class="line">2. +<span class="comment">----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">3. | id | select_type        | table   | type            | possible_keys   | key     | key_len | ref  | rows   | Extra       | </span><br><span class="line">4. +<span class="comment">----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">5. |  1 | PRIMARY            | t_order | ALL             | NULL            | NULL    | NULL    | NULL | 100649 | Using where | </span><br><span class="line">6. |  2 | DEPENDENT SUBQUERY | t_order | unique_subquery | PRIMARY,user_id | PRIMARY | 4       | func |      1 | Using where | </span><br><span class="line">7. +<span class="comment">----+--------------------+---------+-----------------+-----------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>7.index_subquery</strong></p>
<p>该联接类型与上面的太像了，唯一的差别就是子查询查的不是主键而是非唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where user_id in (select user_id from t_order where order_id&gt;10); </span><br><span class="line">2. +<span class="comment">----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ </span></span><br><span class="line">3. | id | select_type        | table   | type           | possible_keys   | key     | key_len | ref  | rows   | Extra                    | </span><br><span class="line">4. +<span class="comment">----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ </span></span><br><span class="line">5. |  1 | PRIMARY            | t_order | ALL            | NULL            | NULL    | NULL    | NULL | 100649 | Using where              | </span><br><span class="line">6. |  2 | DEPENDENT SUBQUERY | t_order | index_subquery | PRIMARY,user_id | user_id | 5       | func |  50324 | Using index; Using where | </span><br><span class="line">7. +<span class="comment">----+--------------------+---------+----------------+-----------------+---------+---------+------+--------+--------------------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>8.range</strong></p>
<p>按指定的范围进行检索，很常见。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where user_id in (100,200,300); </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">3. | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | range | user_id       | user_id | 5       | NULL |    3 | Using where | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>9.index</strong></p>
<p>在进行统计时非常常见，此联接类型实际上会扫描索引树，仅比ALL快些。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select count(*) from t_order; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">3. | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows   | Extra       | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | index | NULL          | user_id | 5       | NULL | 100649 | Using index | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+--------+-------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>10.ALL</strong></p>
<p>完整的扫描全表，最慢的联接类型，尽可能的避免。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+-------+ </span></span><br><span class="line">3. | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+-------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100649 |       | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+-------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="三-extra的说明"><a href="#三-extra的说明" class="headerlink" title="三.extra的说明"></a><strong>三.extra的说明</strong></h3><p><strong>1.Distinct</strong></p>
<p>MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。对于此项没有找到合适的例子，求指点。</p>
<p><strong>2.Not exists</strong></p>
<p>因为b表中的order_id是主键，不可能为NULL，所以mysql在用a表的order_id扫描t_order表，并查找b表的行时，如果在b表发现一个匹配的行就不再继续扫描b了，因为b表中的order_id字段不可能为NULL。这样避免了对b表的多次扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select count(1) from t_order a left join t_order_ext b on a.order_id=b.order_id where b.order_id is null;  </span><br><span class="line">2. +<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ </span></span><br><span class="line">3. | id | select_type | table | type  | possible_keys | key          | key_len | ref             | rows   | Extra                                | </span><br><span class="line">4. +<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | a     | index | NULL          | express_type | 1       | NULL            | 100395 | Using index                          | </span><br><span class="line">6. |  1 | SIMPLE      | b     | ref   | order_id      | order_id     | 4       | test.a.order_id |      1 | Using where; Using index; Not exists | </span><br><span class="line">7. +<span class="comment">----+-------------+-------+-------+---------------+--------------+---------+-----------------+--------+--------------------------------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>3.Range checked for each record</strong></p>
<p>这种情况是mysql没有发现好的索引可用，速度比没有索引要快得多。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order t, t_order_ext s where s.order_id&gt;=t.order_id and s.order_id&lt;=t.order_id and t.express_type&gt;5; </span><br><span class="line">2. +<span class="comment">----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">3. | id | select_type | table | type  | possible_keys        | key          | key_len | ref  | rows | Extra                                          | </span><br><span class="line">4. +<span class="comment">----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t     | range | PRIMARY,express_type | express_type | 1       | NULL |    1 | Using where                                    | </span><br><span class="line">6. |  1 | SIMPLE      | s     | ALL   | order_id             | NULL         | NULL    | NULL |    1 | Range checked for each record (index map: 0x1) | </span><br><span class="line">7. +<span class="comment">----+-------------+-------+-------+----------------------+--------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>4.Using filesort</strong></p>
<p>在有排序子句的情况下很常见的一种情况。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order order by express_type; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ </span></span><br><span class="line">3. | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra          | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | ALL  | NULL          | NULL | NULL    | NULL | 100395 | Using filesort | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+------+---------------+------+---------+------+--------+----------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>5.Using index</strong></p>
<p>这是性能很高的一种情况。当查询所需的数据可以直接从索引树中检索到时，就会出现。上面的例子中有很多这样的例子，不再多举例了。</p>
<p><strong>6.Using temporary</strong></p>
<p>发生这种情况一般都是需要进行优化的。mysql需要创建一张临时表用来处理此类查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order a left join t_order_ext b on a.order_id=b.order_id group by b.order_id; </span><br><span class="line">2. +<span class="comment">----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ </span></span><br><span class="line">3. | id | select_type | table | type | possible_keys | key      | key_len | ref             | rows   | Extra                           | </span><br><span class="line">4. +<span class="comment">----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | a     | ALL  | NULL          | NULL     | NULL    | NULL            | 100395 | Using temporary; Using filesort | </span><br><span class="line">6. |  1 | SIMPLE      | b     | ref  | order_id      | order_id | 4       | test.a.order_id |      1 |                                 | </span><br><span class="line">7. +<span class="comment">----+-------------+-------+------+---------------+----------+---------+-----------------+--------+---------------------------------+ </span></span><br><span class="line">8. 2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>7.Using where</strong></p>
<p>当有where子句时，extra都会有说明。</p>
<p><strong>8.Using sort_union(…)/Using union(…)/Using intersect(…)</strong></p>
<p>下面的例子中user_id是一个检索范围，此时mysql会使用sort_union函数来进行索引的合并。而当user_id是一个固定值时，请参看上面type说明5.index_merge的例子，此时会使用union函数进行索引合并。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where order_id=100 or user_id&gt;10; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">3. | id | select_type | table   | type        | possible_keys   | key             | key_len | ref  | rows | Extra                                          | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | index_merge | PRIMARY,user_id | user_id,PRIMARY | 5,4     | NULL |    2 | Using sort_union(user_id,PRIMARY); Using where | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>对于Using intersect的例子可以参看下例，user_id与express_type发生了索引交叉合并。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select * from t_order where express_type=1 and user_id=100; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ </span></span><br><span class="line">3. | id | select_type | table   | type        | possible_keys        | key                  | key_len | ref  | rows | Extra                                              | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | index_merge | user_id,express_type | user_id,express_type | 5,1     | NULL |    1 | Using intersect(user_id,express_type); Using where | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------------+----------------------+----------------------+---------+------+------+----------------------------------------------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>9.Using index for group-by</strong></p>
<p>表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysql&gt; explain select user_id from t_order group by user_id; </span><br><span class="line">2. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ </span></span><br><span class="line">3. | id | select_type | table   | type  | possible_keys | key     | key_len | ref  | rows | Extra                    | </span><br><span class="line">4. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ </span></span><br><span class="line">5. |  1 | SIMPLE      | t_order | range | NULL          | user_id | 5       | NULL |    3 | Using index for group-by | </span><br><span class="line">6. +<span class="comment">----+-------------+---------+-------+---------------+---------+---------+------+------+--------------------------+ </span></span><br><span class="line">7. 1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>除了上面的三个说明，还需要注意rows的数值，多行之间的数值是乘积的关系，可以估算大概要处理的行数，如果乘积很大，那就很有优化的必要了。</p>



            <!-- Pager -->
            <ul class="pager">
                
                
                <li class="next">
                    <a href="/lhj/2019/06/19/程序员需要知道的缩写和专业名词/">Next Post &rarr;</a>
                </li>
                
            </ul>



        </div>
        <!-- Sidebar container-->
        <div class="
    col-lg-3 col-lg-offset-0
    col-md-3 col-md-offset-0
    col-sm-12
    col-xs-12
    sidebar-container
">
            <!-- toc -->
            <div class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix-top" role="complementary">
                <h4><i class="fa fa-bookmark"></i> Catalog</h4>
                <ul class="nav bs-docs-sidenav">

                </ul>

            </div>

        </div>
    </div>
</div>

<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; keep moving on 2019
                    <br>
                    Theme by <a href="http://beantech.org/">Bean Tech</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="https://1006400320.github.io/lhj">keep moving on</a>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/lhj/js/script.js"></script>




</body>
</html>